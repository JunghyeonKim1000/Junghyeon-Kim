# Junghyeon-Kim
JS 기초 공부

### 예제 1-1
---
변할 수 있는 데이터를 만든다라는 뜻으로 이 데이터의 식별자는 a로 하겠다는 뜻이다.

### 예제 1-2
---
1, 2번째 줄과 4번째 줄은 모두 같은 동작을 수행한다. 
하지만 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다.

### 예제 1-3
---
문자열 값도 한 번 만든 값을 바꿀 수 없고, 숫자 값도 다른 값으로 변경할 수 없다. 변경은 새로 만드는 동작을 통해서만 이뤄진다.

### 예제 1-4
---
참조형 데이터를 변수에 할당하는 과정이며, 기본형 이터와의 차이는 '객체의 변수 영역'이 별도로 존재한다는 점이다.

### 예제 1-5
---
새로운 객체가 만들진 것이 아니라 기존의 객체 내부의 값만 바뀐것이다.

### 예제 1-6
---
참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우로 이런 경우를 일컬어 중첩 객체라고 한다.

### 예제 1-7
---
변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일하다.

### 예제 1-8
---
변수 a와 변수 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1과 obj2는 여전히 같은 객체를 바라보고 있는 상태이며, 이 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점이다.

### 예제 1-9
---
이번에는 obj2에도 새로운 객체를 할당함으로써 값을 직접 변경했으며, 이렇게 할시 메모리의 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 위치에 저장하게 된다. 따라서 객체에 대한 변경임에도 값이 달라졌다.
이를 요약하면 참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립된다.

### 예제 1-10
---
본 예제는 객체의 가변성으로 인한 문제점을 보여주는 간단한 예시로 정보가 바뀐 시점에 알림을 보내야 한다거나, 바뀌기 전의 정보와 바뀐 후의 정보의 차이를 가시적으로 보여줘야 하는 등의 기능을 구현하려면 다른 형식으로 써야합니다.

### 예제 1-11
---
ChangeName 함수가 새로운 객체를 반환하도록 수정하였다. 하지만 이런식으로는 대상 객체에 정보가 많을수록, 변경해야 할 정보가 많을수록 입력하는 수고가 늘어날 것으로 예상된다.

### 예제 1-12
---
copyObject는 for in 문법을 이용해 result 객체에 target 객체의 프로퍼티들을 복사하는 함수이다. 

### 예제 1-13
---
copyObject 함수를 통해 간단하게 객체를 복사하고 내용을 수정하는 데 성공하였지만 이러한 방법은 모든 개발자들이 이 함수를 사용하기로 합의하고 그 규칙을 지킨다는 전제하에서만 불변 객체라고 볼 수 있다. 

### 예제 1-14
---
user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어졌지만 한 단계 더 들어간 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조하는 것이다.

### 예제 1-15
---
어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야한다. 

### 예제 1-16
---
이 함수를 사용해 객체를 복사한 다음에는 원본과 사본이 서로 완전히 다른 객체를 참조하게 되어 어느 쪽의 프로퍼티를 변경하더라도 다른 쪽에 영향을 주지 않는다.

### 예제 1-17
---
추가로 hasOwnProperty method를 활용해 프로토타입 체이닝을 통해 상속된 property를 복사하지 않게끔 할 수도 있다.

### 예제 1-18
---
본 예제는 간단하게 깊은 복사를 처리할 수 있는 다른 방법이다. 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 것이며, 이 방법은 단순함에도 불구하고 잘 동작한다.

### 예제 1-19
---
자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 거싱라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환한다. 다음 세 경우가 이에 해당한다.

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

예제 1-19는 자동으로 undefined를 부여하는 경우에 대한 예제이다.

### 예제 1-20
---
비어있는 요소와 undefined를 할당한 요소는 출력 결과부터 다르다. 비어있는 요소는 순회와 관련된 많은 배열 method들의 순회 대상에서 제외된다. 

### 예제 1-21
---
사용자가 아무것도 하지 않은 채로 접근했을 때 자바 스크립트 엔진이 하는 수 없이 반환해주는 undefined는 해당 프로퍼티 내지 배열의 키값 자체가 존재하지 않음을 의미한다. 값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타내는 것이다.

### 예제 1-22
---
어떤 변수가 실제로 null 인지 아니면 undefined 인지는 동등 연산자로 비교해서는 알 수 없다. 7번째 및 8번째 줄과 같이 일치 연산자를 써야만 정확히 판별할 수 있다.
