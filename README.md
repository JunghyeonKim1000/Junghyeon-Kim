# Junghyeon-Kim
JS 기초 공부

### 예제 1-1
---
변할 수 있는 데이터를 만든다라는 뜻으로 이 데이터의 식별자는 a로 하겠다는 뜻이다.

### 예제 1-2
---
1, 2번째 줄과 4번째 줄은 모두 같은 동작을 수행한다. 
하지만 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다.

### 예제 1-3
---
문자열 값도 한 번 만든 값을 바꿀 수 없고, 숫자 값도 다른 값으로 변경할 수 없다. 변경은 새로 만드는 동작을 통해서만 이뤄진다.

### 예제 1-4
---
참조형 데이터를 변수에 할당하는 과정이며, 기본형 이터와의 차이는 '객체의 변수 영역'이 별도로 존재한다는 점이다.

### 예제 1-5
---
새로운 객체가 만들진 것이 아니라 기존의 객체 내부의 값만 바뀐것이다.

### 예제 1-6
---
참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우로 이런 경우를 일컬어 중첩 객체라고 한다.

### 예제 1-7
---
변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일하다.

### 예제 1-8
---
변수 a와 변수 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1과 obj2는 여전히 같은 객체를 바라보고 있는 상태이며, 이 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점이다.

### 예제 1-9
---
이번에는 obj2에도 새로운 객체를 할당함으로써 값을 직접 변경했으며, 이렇게 할시 메모리의 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 위치에 저장하게 된다. 따라서 객체에 대한 변경임에도 값이 달라졌다.
이를 요약하면 참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립된다.

### 예제 1-10
---
본 예제는 객체의 가변성으로 인한 문제점을 보여주는 간단한 예시로 정보가 바뀐 시점에 알림을 보내야 한다거나, 바뀌기 전의 정보와 바뀐 후의 정보의 차이를 가시적으로 보여줘야 하는 등의 기능을 구현하려면 다른 형식으로 써야합니다.

### 예제 1-11
---
ChangeName 함수가 새로운 객체를 반환하도록 수정하였다. 하지만 이런식으로는 대상 객체에 정보가 많을수록, 변경해야 할 정보가 많을수록 입력하는 수고가 늘어날 것으로 예상된다.

### 예제 1-12
---
copyObject는 for in 문법을 이용해 result 객체에 target 객체의 프로퍼티들을 복사하는 함수이다. 

### 예제 1-13
---
copyObject 함수를 통해 간단하게 객체를 복사하고 내용을 수정하는 데 성공하였지만 이러한 방법은 모든 개발자들이 이 함수를 사용하기로 합의하고 그 규칙을 지킨다는 전제하에서만 불변 객체라고 볼 수 있다. 

### 예제 1-14
---
user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어졌지만 한 단계 더 들어간 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조하는 것이다.

### 예제 1-15
---
어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야한다. 

### 예제 1-16
---
이 함수를 사용해 객체를 복사한 다음에는 원본과 사본이 서로 완전히 다른 객체를 참조하게 되어 어느 쪽의 프로퍼티를 변경하더라도 다른 쪽에 영향을 주지 않는다.

### 예제 1-17
---
추가로 hasOwnProperty method를 활용해 프로토타입 체이닝을 통해 상속된 property를 복사하지 않게끔 할 수도 있다.

### 예제 1-18
---
본 예제는 간단하게 깊은 복사를 처리할 수 있는 다른 방법이다. 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 것이며, 이 방법은 단순함에도 불구하고 잘 동작한다.

### 예제 1-19
---
자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 거싱라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환한다. 다음 세 경우가 이에 해당한다.

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

예제 1-19는 자동으로 undefined를 부여하는 경우에 대한 예제이다.

### 예제 1-20
---
비어있는 요소와 undefined를 할당한 요소는 출력 결과부터 다르다. 비어있는 요소는 순회와 관련된 많은 배열 method들의 순회 대상에서 제외된다. 

### 예제 1-21
---
사용자가 아무것도 하지 않은 채로 접근했을 때 자바 스크립트 엔진이 하는 수 없이 반환해주는 undefined는 해당 프로퍼티 내지 배열의 키값 자체가 존재하지 않음을 의미한다. 값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타내는 것이다.

### 예제 1-22
---
어떤 변수가 실제로 null 인지 아니면 undefined 인지는 동등 연산자로 비교해서는 알 수 없다. 7번째 및 8번째 줄과 같이 일치 연산자를 써야만 정확히 판별할 수 있다.

### 예제 2-1
---
콜 스택에 실행 컨테스트가 어떤 순서로 쌓이고, 어떤 순서로 코드 실행에 관여하는지 확인할 수 있는 예제이다.

### 예제 2-2
---
(1)에는 함수 호출 시 전달한 1이 출력되고, (2)는 선언된 변수 x에 할당한 값이 없으므로 undefined가 출력되고, (3)에서는 2가 출력될 것이다.

### 예제 2-3
---
environment Record는 현재 실행될 컨텍스트의 대상 코드내에 어떤 식별자들이 있는지에만 관심이 있고, 각 식별자에 어떤 값이 할당될 것인지는 관심이 없다. 따라서 변수를 호이스팅할 때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둔다.

### 예제 2-4
---
호이스팅이 끝난예제이다.

### 예제 2-5
---
출력 결과는 (1)에는 b의 값이 없으니 에러가 나거나 undefined가 나올 것으로 예상되고, (2)는 bbb, (3)은 b 함수가 출력될 것으로 예상된다.

### 예제 2-6
---
수집 대상 1과 2를 순서대로 끌어올리고 난 형태이다.

### 예제 2-7
---
해석의 편의를 위해 예제 2-6에서 한가지를 더 바꾼 코드이다.

### 예제 2-8
---
함수를 정의하는 3가지 방식에 대한 예제이다.

### 예제 2-9
---
실행 컨텍스트의 lexicalEnviroment는 두 가지 정보를 수집하는데, 여기서는 그중에서 environmentRecord의 정보 수집 과정에서 발생하는 호이스팅을 살펴보는 중이다.

### 예제 2-10
---
함수 선언문은 전체를 호이스팅한 반면 함수 표현식은 변수 선언부만 호이스팅하였다. 함수도 하나의 값으로 취급할 수 있다는 것을 보여준 예제이다.

### 예제 2-11
---
맨 마지막에 선언된 함수 이외에는 오류가 생기는 예제이다.

### 예제 2-12
---
상대적으로 함수 표현식이 안전하다는 것을 보여주는 극단적인 예시이다.

### 예제 2-13
---
스코프 체인에 관한 예제로 여기서 스코프란 식별자에 대한 유효범위를 의미한다. 스코프 체인은 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색하 나가는 것을 의미한다.

### 예제 2-14
---
스코프 체인을 확인하는 예제 1이다. 교재 p 58 참고.

### 예제 2-15
---
스코프 체인을 확인하는 예제 2이다. 교재 p 59 참고.

### 예제 2-16
---
스코프 체인을 확인하는 예제 3이다. 교재 p 60 참고.

### 예제 3-1
---
전역 공간에서의 this를 브라우저 환경을 기준으로 보여주는 예제이다. 교재 p 66 참고.

### 예제 3-2
---
전역 공간에서의 this를 Node.js 환경을 기준으로 보여주는 예제이다. 교재 p 66 참고.

### 예제 3-3
---
전역공간에서 선언한 변수 a에 1을 할당했을 뿐인데 window.a와 this.a 모두 1이 출력되는 것을 볼 수 있다. 그 이유는 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로서 동작하기 때문이다.

### 예제 3-4
---


### 예제 3-5
---
변수에 delete 연산자를 쓰는 것이 이상해보일 수도 있는데, window.를 생략한 것으로 이해하면 된다. 전역변수가 곧 전역객체의 프로퍼티이므로 문제가 되지 않는다.

### 예제 3-6
---
익명함수는 그대로인데 이를 변수에 담아 호출한 경우와 obj 객체의 프로퍼티에 할당해서 호출한 경우에 this가 달라지는 것이다.

### 예제 3-7
---
점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것이고, 그렇지 않은 모든 경우에는 함수로 호출한 것이다.

### 예제 3-8
---
어떤 함수를 method로서 호출하는 경우 호출 주체는 바로 함수명 앞의 객체이다. 점 표기법의 경우 마지막 점앞에 명시된 객체가 곧 this가 되는 것이다.

### 예제 3-9
---
본 예제에서 (1)은 obj1, (2)는 전역객체, (3)은 obj2를 가리킨다.

### 예제 3-10
---
내부함수에서의 this를 우회하는 방법과 관련된 예제로, 우회라고 할 수도 없을 만큼 허무한 방법이지만 충분히 결과는 좋다.

### 예제 3-11
---
화살표 함수는 실행 컨텍스트를 생설할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다.

### 예제 3-12
---
콜백 함수의 제어권을 가지는 함수가 콜백 함수에서의 this를 무엇으로 할지를 결정하며, 특별히 정의하지 않는 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.

### 예제 3-13
---
Cat이란 변수에 익명 함수를 할당했다. 이 함수 내부에서는 this에 접근하여 bark, name, age 프로퍼티에 각각 값을 대입한다. ~
교재 p 79에 자세히 설명이 나와있다.

### 예제 3-14
---
call 메서드는 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령이다. 이때 call 메서드의 첫 번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 한다.

### 예제 3-15
---
객체의 메서드를 그냥 호출하면 this는 객체를 참조하지만 call 메서드를 이용하면 임의의 객체를 this로 지정할 수 있다.

### 예제 3-16
---
apply 메서드는 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서 call 메서드와 차이점이 있다.

### 예제 3-17
---
call 메서드를 이용해 원본인 유사배열객체의 얕은 복사를 수행한 것인데, slice 메서드가 배열 메서드이기 때문에 복사본은 배열로 반환하게 된 것이다.

### 예제 3-18
---
함수 내부에서 접근할 수 있는 arguments 객체도 유사배열객체이므로 위의 방법으로 전환해서 활용할 수 있다는 것을 보여주는 예제이다.

### 예제 3-19
---
call/apply 메서드를 이용해 모든 배열 메서드를 적용할 수 있다는 것을 보여주는 예제이다.

### 예제 3-20
---
유사배열객체 또는 순회 가능한 모든 종류의 데이터 타입을 배열로 전환하는 Array.from 메서드를 보여주는 예제이다.

### 예제 3-21
---
생성자 내부에 다른 생성자와 공통된 내용이 있을 경우 call 또는 apply를 이용해 다른 생성자를 호출하면 간단하게 반복을 줄일 수 있다. 

### 예제 3-22
---
배열에서 최대/최솟값을 구해야 할 경우 apply를 사용하지 않는다면 부득이하게 다음 예제처럼 직접 구현해야한다.

### 예제 3-23
---
Math.max/Math.min 메서드에 apply를 적용하면 예제 3-22보다 더 좋은 코딩을 할 수 있다.

### 예제 3-24
---
call/apply 메서드는 명시적으로 별도의 this를 바인딩하면서 함수 또는 메서드를 실행하는 훌륭한 방법이지만 오히려 이로 인해 this를 예측하기 어렵게 만들어 코드 해석을 방해한다는 단점이 있다.
하지만 ES5 이하의 환경에서는 마땅한 대안이 없기 때문에 실무에서 매우 광범위하게 활용되고 있다.

### 예제 3-25
---
본 예제는 bind 메서드에 대한 예제를 보여주고 있다. bind 메서드는 ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨 받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드이다.

### 예제 3-26
---
어떤 함수의 name 프로퍼티가 bound xxx라면 이는 곧 함수명이 xxx인 원본 함수에 bind 메서드를 적용한 새로운 함수라는 의미가 되므로 기존의 call이나 apply 보다 코드를 추적하기에 더 수월해지는 면이 있으며, 이를 보여주는 예제이다.

### 예제 3-27
---
call, apply 또는 bind 메서드를 이용하면 더 깔끔하게 처리할 수 있으며, call을 사용했을 때와 bind를 사용했을 때의 차이점을 보여주는 예제이다.

### 예제 3-28
---
콕밸 함수 내에서의 this에 관여하는 함수 또는 메서드에 대해서도 bind 메서드를 이용하면 this 값을 사용자의 의도대로 바꿀 수 있으며, 이를 보여주는 예제이다.

### 예제 3-29
---
ES6에 새롭게 도입된 화살표 함수는 실행 컨텍스트 생성 시 this를 바인딩하는 과정이 제외되었다. 이 함수 내부에는 this가 아예 없으며, 접근하고자 하면 스코프체인상 가장 가까운 this에 접근하게 된다. 이를 보여주는 예제이다.

### 예제 3-30
---
콜백 함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체(thisArg)를 인자로 지정할 수 있는 경우가 있다. 이러한 메서드의 thisArg 값을 지정하면 콜백 함수 내부에서 this 값을 원하는 대로 변경할 수 있다.

### 예제 3-31
---
thisArg를 인자로 받는 메서드에 대한 문법을 나열한 예제이다.
