# Junghyeon-Kim
JS 기초 공부

### 예제 1-1
---
변할 수 있는 데이터를 만든다라는 뜻으로 이 데이터의 식별자는 a로 하겠다는 뜻이다.

### 예제 1-2
---
1, 2번째 줄과 4번째 줄은 모두 같은 동작을 수행한다. 
하지만 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다.

### 예제 1-3
---
문자열 값도 한 번 만든 값을 바꿀 수 없고, 숫자 값도 다른 값으로 변경할 수 없다. 변경은 새로 만드는 동작을 통해서만 이뤄진다.

### 예제 1-4
---
참조형 데이터를 변수에 할당하는 과정이며, 기본형 이터와의 차이는 '객체의 변수 영역'이 별도로 존재한다는 점이다.

### 예제 1-5
---
새로운 객체가 만들진 것이 아니라 기존의 객체 내부의 값만 바뀐것이다.

### 예제 1-6
---
참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우로 이런 경우를 일컬어 중첩 객체라고 한다.

### 예제 1-7
---
변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일하다.

### 예제 1-8
---
변수 a와 변수 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1과 obj2는 여전히 같은 객체를 바라보고 있는 상태이며, 이 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점이다.

### 예제 1-9
---
이번에는 obj2에도 새로운 객체를 할당함으로써 값을 직접 변경했으며, 이렇게 할시 메모리의 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 위치에 저장하게 된다. 따라서 객체에 대한 변경임에도 값이 달라졌다.
이를 요약하면 참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립된다.

### 예제 1-10
---
본 예제는 객체의 가변성으로 인한 문제점을 보여주는 간단한 예시로 정보가 바뀐 시점에 알림을 보내야 한다거나, 바뀌기 전의 정보와 바뀐 후의 정보의 차이를 가시적으로 보여줘야 하는 등의 기능을 구현하려면 다른 형식으로 써야합니다.

### 예제 1-11
---
ChangeName 함수가 새로운 객체를 반환하도록 수정하였다. 하지만 이런식으로는 대상 객체에 정보가 많을수록, 변경해야 할 정보가 많을수록 입력하는 수고가 늘어날 것으로 예상된다.

### 예제 1-12
---
copyObject는 for in 문법을 이용해 result 객체에 target 객체의 프로퍼티들을 복사하는 함수이다. 

### 예제 1-13
---
copyObject 함수를 통해 간단하게 객체를 복사하고 내용을 수정하는 데 성공하였지만 이러한 방법은 모든 개발자들이 이 함수를 사용하기로 합의하고 그 규칙을 지킨다는 전제하에서만 불변 객체라고 볼 수 있다. 

### 예제 1-14
---
user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어졌지만 한 단계 더 들어간 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조하는 것이다.

### 예제 1-15
---
어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야한다. 

### 예제 1-16
---
이 함수를 사용해 객체를 복사한 다음에는 원본과 사본이 서로 완전히 다른 객체를 참조하게 되어 어느 쪽의 프로퍼티를 변경하더라도 다른 쪽에 영향을 주지 않는다.

### 예제 1-17
---
추가로 hasOwnProperty method를 활용해 프로토타입 체이닝을 통해 상속된 property를 복사하지 않게끔 할 수도 있다.

### 예제 1-18
---
본 예제는 간단하게 깊은 복사를 처리할 수 있는 다른 방법이다. 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 것이며, 이 방법은 단순함에도 불구하고 잘 동작한다.

### 예제 1-19
---
자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 거싱라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환한다. 다음 세 경우가 이에 해당한다.

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

예제 1-19는 자동으로 undefined를 부여하는 경우에 대한 예제이다.

### 예제 1-20
---
비어있는 요소와 undefined를 할당한 요소는 출력 결과부터 다르다. 비어있는 요소는 순회와 관련된 많은 배열 method들의 순회 대상에서 제외된다. 

### 예제 1-21
---
사용자가 아무것도 하지 않은 채로 접근했을 때 자바 스크립트 엔진이 하는 수 없이 반환해주는 undefined는 해당 프로퍼티 내지 배열의 키값 자체가 존재하지 않음을 의미한다. 값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타내는 것이다.

### 예제 1-22
---
어떤 변수가 실제로 null 인지 아니면 undefined 인지는 동등 연산자로 비교해서는 알 수 없다. 7번째 및 8번째 줄과 같이 일치 연산자를 써야만 정확히 판별할 수 있다.

### 예제 2-1
---
콜 스택에 실행 컨테스트가 어떤 순서로 쌓이고, 어떤 순서로 코드 실행에 관여하는지 확인할 수 있는 예제이다.

### 예제 2-2
---
(1)에는 함수 호출 시 전달한 1이 출력되고, (2)는 선언된 변수 x에 할당한 값이 없으므로 undefined가 출력되고, (3)에서는 2가 출력될 것이다.

### 예제 2-3
---
environment Record는 현재 실행될 컨텍스트의 대상 코드내에 어떤 식별자들이 있는지에만 관심이 있고, 각 식별자에 어떤 값이 할당될 것인지는 관심이 없다. 따라서 변수를 호이스팅할 때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둔다.

### 예제 2-4
---
호이스팅이 끝난예제이다.

### 예제 2-5
---
출력 결과는 (1)에는 b의 값이 없으니 에러가 나거나 undefined가 나올 것으로 예상되고, (2)는 bbb, (3)은 b 함수가 출력될 것으로 예상된다.

### 예제 2-6
---
수집 대상 1과 2를 순서대로 끌어올리고 난 형태이다.

### 예제 2-7
---
해석의 편의를 위해 예제 2-6에서 한가지를 더 바꾼 코드이다.

### 예제 2-8
---
함수를 정의하는 3가지 방식에 대한 예제이다.

### 예제 2-9
---
실행 컨텍스트의 lexicalEnviroment는 두 가지 정보를 수집하는데, 여기서는 그중에서 environmentRecord의 정보 수집 과정에서 발생하는 호이스팅을 살펴보는 중이다.

### 예제 2-10
---
함수 선언문은 전체를 호이스팅한 반면 함수 표현식은 변수 선언부만 호이스팅하였다. 함수도 하나의 값으로 취급할 수 있다는 것을 보여준 예제이다.

### 예제 2-11
---
맨 마지막에 선언된 함수 이외에는 오류가 생기는 예제이다.

### 예제 2-12
---
상대적으로 함수 표현식이 안전하다는 것을 보여주는 극단적인 예시이다.

### 예제 2-13
---
스코프 체인에 관한 예제로 여기서 스코프란 식별자에 대한 유효범위를 의미한다. 스코프 체인은 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색하 나가는 것을 의미한다.

### 예제 2-14
---
스코프 체인을 확인하는 예제 1이다. 교재 p 58 참고.

### 예제 2-15
---
스코프 체인을 확인하는 예제 2이다. 교재 p 59 참고.

### 예제 2-16
---
스코프 체인을 확인하는 예제 3이다. 교재 p 60 참고.

### 예제 3-1
---
전역 공간에서의 this를 브라우저 환경을 기준으로 보여주는 예제이다. 교재 p 66 참고.

### 예제 3-2
---
전역 공간에서의 this를 Node.js 환경을 기준으로 보여주는 예제이다. 교재 p 66 참고.

### 예제 3-3
---
전역공간에서 선언한 변수 a에 1을 할당했을 뿐인데 window.a와 this.a 모두 1이 출력되는 것을 볼 수 있다. 그 이유는 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로서 동작하기 때문이다.

### 예제 3-4
---


### 예제 3-5
---
변수에 delete 연산자를 쓰는 것이 이상해보일 수도 있는데, window.를 생략한 것으로 이해하면 된다. 전역변수가 곧 전역객체의 프로퍼티이므로 문제가 되지 않는다.

### 예제 3-6
---
익명함수는 그대로인데 이를 변수에 담아 호출한 경우와 obj 객체의 프로퍼티에 할당해서 호출한 경우에 this가 달라지는 것이다.

### 예제 3-7
---
점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것이고, 그렇지 않은 모든 경우에는 함수로 호출한 것이다.

### 예제 3-8
---
어떤 함수를 method로서 호출하는 경우 호출 주체는 바로 함수명 앞의 객체이다. 점 표기법의 경우 마지막 점앞에 명시된 객체가 곧 this가 되는 것이다.

### 예제 3-9
---
본 예제에서 (1)은 obj1, (2)는 전역객체, (3)은 obj2를 가리킨다.

### 예제 3-10
---
내부함수에서의 this를 우회하는 방법과 관련된 예제로, 우회라고 할 수도 없을 만큼 허무한 방법이지만 충분히 결과는 좋다.

### 예제 3-11
---
화살표 함수는 실행 컨텍스트를 생설할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다.

### 예제 3-12
---
콜백 함수의 제어권을 가지는 함수가 콜백 함수에서의 this를 무엇으로 할지를 결정하며, 특별히 정의하지 않는 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.

### 예제 3-13
---
Cat이란 변수에 익명 함수를 할당했다. 이 함수 내부에서는 this에 접근하여 bark, name, age 프로퍼티에 각각 값을 대입한다. ~
교재 p 79에 자세히 설명이 나와있다.

### 예제 3-14
---
call 메서드는 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령이다. 이때 call 메서드의 첫 번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 한다.

### 예제 3-15
---
객체의 메서드를 그냥 호출하면 this는 객체를 참조하지만 call 메서드를 이용하면 임의의 객체를 this로 지정할 수 있다.

### 예제 3-16
---
apply 메서드는 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서 call 메서드와 차이점이 있다.

### 예제 3-17
---
call 메서드를 이용해 원본인 유사배열객체의 얕은 복사를 수행한 것인데, slice 메서드가 배열 메서드이기 때문에 복사본은 배열로 반환하게 된 것이다.

### 예제 3-18
---
함수 내부에서 접근할 수 있는 arguments 객체도 유사배열객체이므로 위의 방법으로 전환해서 활용할 수 있다는 것을 보여주는 예제이다.

### 예제 3-19
---
call/apply 메서드를 이용해 모든 배열 메서드를 적용할 수 있다는 것을 보여주는 예제이다.

### 예제 3-20
---
유사배열객체 또는 순회 가능한 모든 종류의 데이터 타입을 배열로 전환하는 Array.from 메서드를 보여주는 예제이다.

### 예제 3-21
---
생성자 내부에 다른 생성자와 공통된 내용이 있을 경우 call 또는 apply를 이용해 다른 생성자를 호출하면 간단하게 반복을 줄일 수 있다. 

### 예제 3-22
---
배열에서 최대/최솟값을 구해야 할 경우 apply를 사용하지 않는다면 부득이하게 다음 예제처럼 직접 구현해야한다.

### 예제 3-23
---
Math.max/Math.min 메서드에 apply를 적용하면 예제 3-22보다 더 좋은 코딩을 할 수 있다.

### 예제 3-24
---
call/apply 메서드는 명시적으로 별도의 this를 바인딩하면서 함수 또는 메서드를 실행하는 훌륭한 방법이지만 오히려 이로 인해 this를 예측하기 어렵게 만들어 코드 해석을 방해한다는 단점이 있다.
하지만 ES5 이하의 환경에서는 마땅한 대안이 없기 때문에 실무에서 매우 광범위하게 활용되고 있다.

### 예제 3-25
---
본 예제는 bind 메서드에 대한 예제를 보여주고 있다. bind 메서드는 ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨 받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드이다.

### 예제 3-26
---
어떤 함수의 name 프로퍼티가 bound xxx라면 이는 곧 함수명이 xxx인 원본 함수에 bind 메서드를 적용한 새로운 함수라는 의미가 되므로 기존의 call이나 apply 보다 코드를 추적하기에 더 수월해지는 면이 있으며, 이를 보여주는 예제이다.

### 예제 3-27
---
call, apply 또는 bind 메서드를 이용하면 더 깔끔하게 처리할 수 있으며, call을 사용했을 때와 bind를 사용했을 때의 차이점을 보여주는 예제이다.

### 예제 3-28
---
콕밸 함수 내에서의 this에 관여하는 함수 또는 메서드에 대해서도 bind 메서드를 이용하면 this 값을 사용자의 의도대로 바꿀 수 있으며, 이를 보여주는 예제이다.

### 예제 3-29
---
ES6에 새롭게 도입된 화살표 함수는 실행 컨텍스트 생성 시 this를 바인딩하는 과정이 제외되었다. 이 함수 내부에는 this가 아예 없으며, 접근하고자 하면 스코프체인상 가장 가까운 this에 접근하게 된다. 이를 보여주는 예제이다.

### 예제 3-30
---
콜백 함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체(thisArg)를 인자로 지정할 수 있는 경우가 있다. 이러한 메서드의 thisArg 값을 지정하면 콜백 함수 내부에서 this 값을 원하는 대로 변경할 수 있다.

### 예제 3-31
---
thisArg를 인자로 받는 메서드에 대한 문법을 나열한 예제이다.

### 예제 4-1
---
첫 번째 줄은 count 변수를 선언하고 0을 할당한 것이고, 두 번째 줄은 timer 변수를 선언하고 여기에 setInterval을 실행한 결과를 할당한 것이다. setInterval를 실행하면 반복적으로 실행되는 내용 자체를 특정할 수 있는 고유한 ID 값이 반환된다.

### 예제 4-2
---
timer 변수에는 setInterval의 ID 값이 담긴다. setInterval에 전달한 cbFunc 함수는 0.3초마다 자동으로 실행된다. 콜백 함수 내부에서는 count 값을 출력하고, count를 1만큼 증가시킨 다음, 그 값이 4보다 크면 반복 실행을 종료하라고 한다.
여기서 핵심은 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 호출 시점에 대한 제어권을 가진다.

### 예제 4-3
---
map 메서드는 메서드의 대상이 되는 배열의 모든 요소들을 처음부터 끝까지 하나씩 꺼내어 콜백 함수를 반복 호출하고, 콜백 함수의 실행 결과들을 모아 새로운 배열을 만든다. 콜백 함수의 첫 번째 인자에는 배열의 요소 중 현재값이, 두 번째 인자에는 현재값의 인덱스가, 세 번째 인자에는 map 메서드의 대상이 되는 배열 자체가 담긴다.

### 예제 4-4
---
콜백함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가진다.

### 예제 4-5
---
제어권을 넘겨받을 코드에서 call/apply 메서드의 첫 번째 인자에 콜백 함수 내부에서의 this가 될 대상을 명시적으로 바인딩하기 때문이다.

### 예제 4-6
---
(1)의 setTimeout은 내부에서 콜백 함수를 호출할 때 call 메서드의 첫 번째 인자에 전역객체를 넘기기 떄문에 콜백 함수 내부에서의 this가 객체를 가리킨다.
(2)의 forEach는 별도의 인자로 this를 넘겨주지 않았기 때문에 전역객체를 가리키게 된다.
(3)의 addEventListener는 내부에서 콜백 함수를 호출할 때 call 메서드의 첫 번째 인자에 addEventListener 메서드의 this를 그대로 넘기도록 정의돼 있기 때문에 콜백 함수 내부에서의 this가 addEventListener를 호출한 주체인 HTML element를 가리키게 된다.

### 예제 4-7
---
어떤 함수의 인자에 객체의 메서드를 전달하더라도 이는 결국 메서드가 아닌 함수일 뿐이다.

### 예제 4-8
---
obj1.func 메서드 내부에서 self 변수에 this를 담고, 익명 함수를 선언과 동시에 반환한 예제이다. 이 방식은 실제로 this를 사용하지도 않을뿐더러 매우 번거롭다고 할 수 있다.

### 예제 4-9
---
4-8 예제에서 this를 사용하지 않았을 때의 결과이다. 훨씬 간결하고 직관적이지만 아쉬운 부분이 있으며, 작성한 함수를 this를 이용해 다양한 상황에 재활용할 수 없게 되어버렸다는 점이 있다.

### 예제 4-10
---
본 예제의 callback2에는 obj2의 func를 실행한 결과를 담아 이를 콜백으로 사용했다. callback3의 경우 obj1의 func를 실행하면서 this를 obj3가 되도록 지정해 이를 콜백으로 사용했다. 

예제 4-8부터 4-9까지를 요약하면
예제 4-8은 번거롭긴 하지만 this를 우회적으로나마 활용함으로써 다양한 상황에서 원하는 객체를 바라보는 콜백 함수를 만들 수 있는 방법이다.
예제 4-9는 처음부터 바라볼 객체를 명시적으로 obj1로 지정했기 때문에 어떤 방법으로도 다른 객체를 바라보게끔 할 수가 없다.

### 예제 4-11
---
예제 4-11은 bind 메서드를 활용하여 콜백 함수 내부의 this에 다른 값을 바인딩 하는 방법에 관한 예제이다.

### 예제 4-12
---
콜백 지옥은 콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상으로 자바스크립트에서 흔히 발생하는 문제이다. 4-12 예제는 콜백 지옥의 예시를 보여준다.

### 예제 4-13
---
익명의 콜백 함수를 모두 기명함수로 전환함으로써 콜백 지옥을 해결할 수 있다. 이 방식은 코드의 가독성을 높일뿐 아니라 함수 선언과 함수 호출만 구분할 수 있다면 위에서부터 아래로 순서대로 읽어내려가는 데 어려움이 없다.

### 예제 4-14
---
ES6의 Promise를 이용한 방식이다. new 연산자와 함께 호출한 Promise의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 그 내부에 resolve 또는 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지는 다음 또는 오류 구문으로 넘어가지 않는다. 따라서 비동기 작업이 완료될 때 비로소 resolve 또는 reject를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능해진다.

### 예제 4-15
---
예제 4-15는 예제 4-14의 반복적인 내용을 함수화해서 더욱 짧게 표현한 것이다. 

### 예제 4-16
---
예제 4-16은 ES6의 Generator를 이용한 예제이다. Generator 함수를 실행하면 Iterator가 반환되는데, Iterator는 next라는 메서드를 가지고 있다. 이 next 메서드를 호출하면 Generator 함수 내부에서 가장 먼저 등장하는 yield에서 함수의 실행을 멈춘다. 이후 다시 next 메서드를 호출하면 앞서 멈췄던 부분부터 시작해서 그 다음에 등장하는 yield에서 함수의 실행을 멈춘다.

### 예제 4-17
---
ES2017에서는 가독성이 뛰어나면서 작성법도 간단한 새로운 기능이 추가됐는데 이것이 바로 async/await이다. 비동기 작업을 수행하고자 하는 함수 앞에 async를 표기하고, 함수 내부에서 실질적인 비동기 작업이 필요한 위치마다 await를 표기하는 것만으로 뒤의 내용을 Promise로 자동 전환하고, 해당 내용이 resolve된 이후에야 다음으로 진행된다.
즉 Promise의 then과 흡사한 효과를 얻을 수 있다.

### 예제 5-1
---
outer 함수에서 변수 a를 선언했고, outer의 내부함수인 inner 함수에서 a의 값을 1만큼 증가시킨 다음 출력한다. inner 함수 내부에서는 a를 선언하지 않았기 때문에 environmentRecord에서 값을 찾지 못하므로 outerEnvironmentReference에 지정된 상위 컨텍스트인 outer의 LexicalEnvironment에 접근해서 다시 a를 찾는다. 4번째 줄에서는 2가 출력된다. outer 함수의 실행 컨텍스트가 종료되면 LexicalEnvironment에 저장된 식별자들에 대한 참조를 지운다. 그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 가비지 컬렉터의 수집 대상이 된다.

### 예제 5-2
---
예제 5-1과 흡사하지만 결과적으로 outer 함수의 실행 컨텍스트가 종료된 시점에는 a 변수를 참조하는 대상이 없어진다.

### 예제 5-3
---
6번째 줄에서 inner 함수의 실행 결과가 아닌 inner 함수 자체를 반환했는데 이러면 outer 함수의 실행 컨텍스트가 종료될 때 outer2 변수는 outer의 실행 결과인 inner 함수를 참조하게 된다. 이후 9번째에서 outer2를 호출하면 앞서 반환된 함수인 inner가 실행될 것으로 예상된다.

### 예제 5-4
---
5-4는 return 없이도 클로저가 발생하는 경우를 예제로 보여준 케이스인데 (1)은 별도의 외부객체인 window의 메서드에 전달할 콜백 함수 내부에서 지역변수를 참조한다. (2)는 별도의 외부객체인 DOM의 메서드에 등록할 handler 함수 내부에서 지역 변수를 참조한다. 

### 예제 5-5
---
예제 5-5는 예제 5-3과 예제 5-4의 코드에 메모리 해제 코드가 추가된 예제이다. 

### 예제 5-6
---
fruits 변수를 순회하며 li를 생성하고, 각 li를 클릭하면 해당 리스너에 기억된 콜백 함수를 실행하게 하였다.

### 예제 5-7
---
공통 함수로 쓰고자 콜백 함수를 외부로 꺼내어 alertFruit라는 변수에 담았다. 이제 alertFruit을 직접 실행할 수 있다.

### 예제 5-8
---
예제 5-8처럼 코딩을 하면 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점 및 함수 내부에서의 this가 원래의 그것과 달라지는 점은 감안해야한다. 이런 변경사항이 발생하지 않게끔 하면서 이슈를 해결하기 위해서는 bind 메서드가 아닌 다른 방식으로 풀어내야한다.

### 예제 5-9
---
4번째 줄에선 alertFruit 함수 대신 alertFruitBuilder라는 이름의 함수로 작성하였다. 이 함수 내부에서는 다시 익명함수를 반환하는데, 이 익명함수가 바로 기존의 alertFruit 함수이다. 결론적으로는 alertFruitBuilder의 실행 결과로 반환된 함수에는 클로저가 존재한다.

### 예제 5-10
---
본 예제는 자동차 객체를 만들어보는 예제이다. car 변수에 객체를 직접 할당했으며, fuel과 power는 무작위로 생성하고, moved라는 프로퍼티에 총 이동거리를 부여했으며, run 메서드를 실행할 때마다 car 객체의 fuel, moved 값이 변하게 하였다.

### 예제 5-11
---
createCar라는 함수를 실행함으로써 객체를 생성하게 하였다. 변수는 비공개 맴버로 지정해 외부에서의 접근을 제한했고, moved 변수는 getter만을 부여함으로써 읽기 전용 속성을 부여하였다. 이제 외부에서는 오직 run 메서드를 실행하는 것과 현재의 moved 값을 확인하는 두 가지 동작만 할 수 있다. 

### 예제 5-12
---
어뷰징까지 막기 위해서 객체를 return하기 전에 미리 변경할 수 없게끔 조치가 취해진 예제이다.

### 예제 5-13
---
addPartial 함수는 인자 5개를 미리 적용하고, 추후 추가적으로 인자들을 전달하면 모든 인자를 모아 원래의 함수가 실행되는 부분 적용 함수이다. add 함수는 this를 사용하지 않으므로 bind 메서드만으로도 문제 없이 구현됐다. 그러나 this의 값을 변경할 수밖에 없기에 메서드에서는 사용할 수 없을 것으로 예상된다.

### 예제 5-14
---
5-14 예제는 저자가 간단하게 구현해본 부분 적용 함수이다. 첫 번째 인자에는 원본 함수를, 두 번째 인자 이후부터는 미리 적용할 인자들을 전달하고, 반환할 함수에서는 다시 나머지 인자들을 받아 이들을 한데 모아 원본 함수를 호출한다. 또한 실행 시점의 this를 그대로 반영함으로써 this에는 아무런 영향을 주지 않게 되었다. 

### 예제 5-15
---
이번 예제에서는 '비워놓음'을 표시하기 위해 미리 전역객체에 under bar 라는 프로퍼티를 준비하면서 삭제 변경 등의 접근에 대한 방어 차원에서 여러 가지 프로퍼티 속성을 설정했다.

### 예제 5-16
---
출력 용도로 지정한 eventName과 실행할 함수, 마지막으로 발생한 이벤트인지 여부를 판단하기 위한 대기시간을 받는다. 내부에서는 timeoutId 변수를 생성하고, 클로저로 EventListener에 의해 호출될 함수를 반환한다. 반환될 함수 내부에서는, 4번째 줄에서 setTimeout을 사용하기 위해 this를 별도의 변수에 담고, 6번째 줄에서 무조건 대기큐를 초기화하게 했다. 마지막으로 7번째 줄에서 setTimeout으로 wait 시간만큼 지연시킨 다음, 원래의 func를 호출하는 형태이다.
이제 최초 event가 발생하면 7번째 줄에 의해 timeout의 대기열에 wait 시간 뒤에 func를 실행할 것이라는 내용이 담긴다.

### 예제 5-17
---
부분 적용 함수와 달리 커링함수는 필요한 상황에 직접 만들어 쓰기 용이하다. 필요한 인자 개수만큼 함수를 만들어 계속 리턴해주다가 마지막에만 조합해서 리턴해주면 되기 때문이다. 하지만 인자가 많아질수록 가독성이 떨어진다는 단점이 있다.

### 예제 5-18
---
본 예제는 인자가 많아질수록 가독성이 떨어진다는 커링 함수의 단점을 보여주는 예제이다. 5개만 받아서 처리했음에도 이를 표현하기 위해 자그마치 13줄이나 소모하게 된다. ES6에서는 화살표 함수를 써서 같은 내용을 단 한 줄에 표기할 수 있다.

### 예제 6-1
---
Person 객체를 생성할 때 name 값을 인자로 전달하여 name 속성을 초기화하고, getName 메서드를 사용하여 name 속성 값을 가져올 수 있는 예시코드이다.

### 예제 6-2
---
이 코드는 생성자 함수를 정의하고, prototype을 사용하여 메서드와 속성을 추가하고, 객체를 생성하는 방법을 보여준다. 결론적으로 위 코드는 생성자 함수와 프로토타입을 사용하여 객체를 생성하고, 생성된 객체와 생성자 함수의 정보를 콘솔에 출력하는 예시 코드이다.

### 예제 6-3
---
Array와 prototype을 사용하여 객체를 생성하고, 생성된 객체의 생성자에 대한 정보를 확인하는 방법을 보여준다. 즉 위 코드는 Array와 prototype을 사용하여 객체를 생성하고, 생성된 객체의 생성자에 대한 정보를 확인하는 예제이다.

### 예제 6-4
---
다양한 Data type을 생성하고, 이들 데이터 유형의 생성자를 변경하여 새로운 생성자 함수를 사용하는 방법을 보여준다. 실행 결과는 다양한 데이터 유형의 생성자를 NetConstructor로 변경하고, 각 데이터 유형이 NetConstructor의 인스턴스인지 여부를 확인하는 것이다. 실행 결과를 통해 각 데이터 유형의 생성자와 인스턴스 여부를 console에 출력한다.

### 예제 6-5
---
생성자 함수를 사용하여 객체를 생성하고, 생성된 객체와 생성자 함수의 관계를 확인하는 방법을 보여준다. 이 코드의 실행 결과는 다양한 방식으로 Person 생성자를 사용하여 객체를 생성하고, 각 개체가 Person의 인스턴스인지 여부를 확인한다. 실행 결과를 통해 생성된 객체와 해당 객체가 Person의 인스턴스인지를 확인하는 메세지를 출력한다.

### 예제 6-6
---
생성자 함수를 사용하여 객체를 생성하고, 프로토타입을 사용하여 메서드를 추가하는 방법을 보여준다. 실행 결과로는 Person 생성자 함수를 사용하여 객체를 생성하고 생성된 객체에 새로운 메서드를 추가하는 것이다. iu 객체의 getName 메서드를 호출할 때는 추가된 메서드가 호출되어 바로 지금이 출력된다.

### 예제 6-7
---
Array 객체의 메서드와 속성을 사용하여 작업하는 방법을 간단하게 보여주는 예제이다.

### 예제 6-8
---
Array 객체의 toString 메서드와 프로토타입의 역할을 보여준다. 예제 6-8 코드는 배열 객체의 toString 메서드를 사용하여 배열을 문자열로 변환하고, 프로토타입을 통해 해당 메서드를 호출하는 방법을 보여준다. 또한, 배열 자체에 toString 메서드를 재정의하여 원하는 형식으로 문자열을 반환하는 것도 나타낸다.

### 예제 6-9
---
이 코드는 객체의 프로퍼티와 값의 쌍을 배열 형태로 반환하는 getEntries 메서드를 정의하고 사용하는 방법을 보여준다. getEntries라는 메서드를 사용하여 객체의 프로퍼티와 값의 쌍을 배열로 반환하고, 해당 메서드를 사용하여 다양한 데이터 타입에 대한 프로퍼티와 값의 쌍을 출력하는 예제이다.

### 예제 6-10
---
생성자 함수를 사용하여 Grade라는 객체를 생성하는 방법을 보여준다. 다시 한번 정리하면 생성자 함수를 사용하여 Grade 객체를 생성하고, 생성자 함수 내에서 가변 인자를 배열로 변환하여 객체 내에 인덱스와 값을 할당하는 코드이다.

### 얘재 7-1
---
생성자 함수와 프로토타입을 사용하여 사각형 객체를 생성하고, 사각형 객체의 속성과 method를 정의하는 방법을 보여주는 예제이다. 

### 예제 7-2
---
생성자 함수를 사용하여 Grade라는 객체를 생성하고 생성자 함수 내에서 가변 인자를 배열로 변환하여 객체 내에 인덱스와 값을 할당하며, 프로토타입을 통해 array method와 properties를 상속받는 예제이다.

### 예제 7-3
---
생성자 함수를 사용하여 Grade라는 객체를 생성하고, 프로토타입을 통해 배열 메서드와 속성을 상속받는 것 까지는 예제 7-2와 같으나 추가로 배열과 유사한 동작을 확인하는 예시 코드이다.

### 예제 7-4
---
이 코드는 생성자 함수와 프로토타입을 사용하여 Grade라는 객체를 생성하고, 해당 객체에 배열 메서드와 속성을 추가하며 동작을 확인하는 예제이다. 

### 예제 7-5
---
객체지향 프로그램의 개념을 보여주는 예제로, Recetangle과 Square라는 두 가지 객체가 각자의 특성에 맞는 면적을 계산하는 기능을 가지고 있다.

### 예제 7-6
---
이 코드는 Rectangel과 Square라는 두 가지 객체를 생성하고, 각 개체에 너비와 높이 또는 한 변의 길이를 입력받아 면적을 계산하는 기능을 추가한 예제이다.

### 예제 7-7
---
Square 객체가 Rectangle 객체를 상속받아 사용하는 예제이다. Square 객체는 Rectangle 객체의 속성과 메서드를 재사용하면서 한 변의 길이만을 설정하여 정사각형의 면적을 계산할 수 있게 된다.

### 예제 7-8
---
이 코드는 extendClass1 함수를 사용하여 상속을 구현하는 방법을 보여준다. 이를 통해 상위 클래스의 속성과 메서드를 하위 클래스에서 상속받을 수 있고, 필요한 경우 하위 클래스에 새로운 메서드를 추가할 수 있다.

### 예제 7-9
---
이 코드는 extendClass2 함수를 사용하여 상속을 구현하는 방법을 보여준다. 7.8 예제와 매우 유사하다.

### 예제 7-10
---
Rectangle과 Square라는 두 개의 생성자 함수를 활용하여 상속 관계를 구현하는 예시이다. Square 객체는 Rectangle 객체를 상속받으며, 공통적인 기능인 getArea 메서드를 사용할 수 있다. 이를 통해 코드의 중복을 피하고, 객체 간에 유연한 상속 구조를 구현할 수 있다.

### 예제 7-11
---
클래스 상속을 구현하기 위한 함수인 extendClass1을 제공한다. 이 함수를 사용하면 하위 클래스가 상위 클래스의 속성과 메서드를 상속받으면서, 필요에 따라 추가적인 메서드를 정의할 수 있다. 이를 통해 코드의 재사용성을 높일 수 있고, 유연한 상속 구조를 구현할 수 있다.

### 예제 7-12
---
extendClass2 변수에 할당된 즉시 실행 함수를 통해 클래스 상속을 구현한다. 이 방법은 상위 클래스와 하위 클래스 간에 프로토타입 체인을 구성하여 상속 관계를 형성한다. 이를 통해 상위 클래스의 속성과 메서드를 하위 클래스에서 상속받으면서, 필요에 따라 추가적인 메서드를 정의할 수 있다. 이 예제도 7-11과 비슷하게 코드의 재사용성 개선과 유연한 상속구조가 구현 가능하다.

### 예제 7-13
---
extendClass3 함수를 사용하면 Javescript에서 클래스 상속을 간편하게 구현할 수 있다.

### 예제 7-14
---
이 코드는 Javascript에서 클래스 상속과 super 키워드를 모방하는 함수 extendClass를 정의하고 사용하는 예제이다. 이 코드를 실행하면 size is : 100, 100이 출력된다.

### 예제 7-15
---
이 코드는 Javascript에서 ES5와 ES6의 클래스 정의 방식을 비교하는 예제이다. 두 결과의 차이점은 ES5 스타일의 클래스에서 출력했냐, ES6 스타일의 클래스에서 출력했냐의 차이다.

### 예제 7-16
---
이 코드는 Javascript에서 클래스의 상속 및 메서드 오바리이딩을 보여주는 예제이다. 결과적으로 Square 클래스는 Rectangle 클래스를 상속받아 정사각형의 면적을 계산하는 기능을 가지며, 필요에 따라 getArea 메서드를 오버라이딩할 수 있다.

